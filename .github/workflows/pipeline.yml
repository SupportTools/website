name: Docker Build and Push

on:
  workflow_dispatch:
  push:
    branches:
      - main
  schedule:
    - cron: "0 0 * * *" # This will run daily at midnight

jobs:
  Test:
    runs-on: self-hosted-linux

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Uncomment if you want to do a Hugo test build or HTML validation
      # - name: HUGO test build
      #   run: |
      #     docker run --rm -v $(pwd)/blog/:/src -w /src thegeeklab/hugo:latest --panicOnWarning --minify --gc --cleanDestinationDir --destination public --baseURL http://localhost

      # - name: html-validation
      #   run: |
      #     docker run --rm -v $(pwd)/blog/:/src -w /src thegeeklab/vnu vnu --skip-non-html --errors-only --filterfile .vnuignore public/

      - name: Checking for expired content
        run: |
          docker run --rm -v $(pwd)/blog/:/src -w /src thegeeklab/hugo:0.122 list expired

  SecurityScan:
    runs-on: self-hosted-linux
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

  Build:
    runs-on: self-hosted-linux
    needs: [Test, SecurityScan]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: "--debug"

      # Cache Docker layers for improved build performance
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: |
            supporttools/website:v${{ github.run_number }}
            supporttools/website:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          build-args: |
            VERSION=v${{ github.run_number }}
            GIT_COMMIT=${{ github.sha }}
            BUILD_DATE=${{ fromJSON('["' + github.event.repository.updated_at + '"]')[0] }}

      # Move cache for next build
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      # Run Trivy vulnerability scanner on the built image
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'supporttools/website:v${{ github.run_number }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  Publish:
    runs-on: self-hosted-linux
    needs: Build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install gettext
        run: |
          sudo apt-get update && sudo apt-get install -y gettext

      - name: Set up Helm
        uses: azure/setup-helm@v4.2.0

      - name: Helm Lint
        run: helm lint charts/website/

      - name: Package Helm chart
        run: |
          export CHART_VERSION="v${{ github.run_number }}"
          export APP_VERSION="v${{ github.run_number }}"
          export IMAGE_TAG="v${{ github.run_number }}"
          echo "CHART_VERSION=${CHART_VERSION}"
          echo "APP_VERSION=${APP_VERSION}"
          echo "IMAGE_TAG=${IMAGE_TAG}"
          envsubst < charts/website/Chart.yaml.template > charts/website/Chart.yaml
          envsubst < charts/website/values.yaml.template > charts/website/values.yaml
          helm package charts/website --destination helm/repo

      - name: Checkout helm-chart repository
        uses: actions/checkout@v4
        with:
          repository: SupportTools/helm-chart
          path: helm-chart
          token: ${{ secrets.BOT_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.email "github-action@users.noreply.github.com"
          git config --global user.name "GitHub Action"

      - name: Update Helm repository
        run: |
          cp helm/repo/website-*.tgz helm-chart/
          cd helm-chart
          helm repo index . --url https://charts.support.tools/
          git add .
          git commit -m "Update Helm chart for support.tools"
          git push

  Deploy:
    runs-on: self-hosted-linux
    needs: Publish
    strategy:
      max-parallel: 2  # Run two environments in parallel for faster deployment
      matrix:
        include:
          - environment: mst
            order: 1
          - environment: dev
            order: 1
          - environment: qas
            order: 2
          - environment: tst
            order: 2
          - environment: stg
            order: 3
          - environment: prd
            order: 4

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Create Kubeconfig
        run: |
          curl -fsSL -o rancher-projects.tar.gz https://github.com/SupportTools/rancher-projects/releases/download/v0.2.2/rancher-projects_0.2.2_linux_amd64.tar.gz
          tar -xvf rancher-projects.tar.gz
          chmod +x rancher-projects
          sudo mv rancher-projects /usr/local/bin/
          rancher-projects --rancher-server ${{ secrets.CATTLE_SERVER }} \
          --rancher-access-key ${{ secrets.CATTLE_ACCESS_KEY }} \
          --rancher-secret-key ${{ secrets.CATTLE_SECRET_KEY }} \
          --cluster-name a1-ops-prd --project-name "SupportTools" \
          --namespace supporttools --create-kubeconfig --kubeconfig "kubeconfig"

      - name: Deploy ArgoCD Project
        run: kubectl --kubeconfig kubeconfig apply -f argocd/project.yaml

      - name: Deploy Environment - ${{ matrix.environment }}
        uses: nick-invision/retry@v2
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_wait_seconds: 30
          command: |
            ENVIRONMENT=${{ matrix.environment }}
            CHART_VERSION="v${{ github.run_number }}"

            # Check if application exists
            if kubectl --kubeconfig kubeconfig -n argocd get application supporttools-${ENVIRONMENT} &>/dev/null; then
              echo "ArgoCD Application 'supporttools-${ENVIRONMENT}' exists. Patching targetRevision to ${CHART_VERSION}."
              kubectl --kubeconfig kubeconfig -n argocd patch application "supporttools-${ENVIRONMENT}" \
                --type merge \
                -p "{\"spec\":{\"source\":{\"targetRevision\":\"${CHART_VERSION}\"}}}"
            else
              echo "ArgoCD Application 'supporttools-${ENVIRONMENT}' does not exist. Creating..."
              sed "s/CHARTVERSION/${CHART_VERSION}/g" argocd/${ENVIRONMENT}.yaml \
              | kubectl --kubeconfig kubeconfig -n argocd apply -f -
            fi

      - name: Wait for Deployment to Stabilize
        run: |
          MAX_TRIES=30
          SLEEP_TIME=10
          COUNTER=0
          while [ $COUNTER -lt $MAX_TRIES ]; do
            HEALTH_STATUS=$(kubectl --kubeconfig kubeconfig -n argocd get applications supporttools-${{ matrix.environment }} -o jsonpath='{.status.health.status}')
            echo "Current health status: $HEALTH_STATUS"
            if [ "$HEALTH_STATUS" = "Healthy" ]; then
              echo "Application is healthy."
              break
            fi
            echo "Waiting for application to become healthy..."
            sleep $SLEEP_TIME
            let COUNTER=COUNTER+1
          done
          if [ $COUNTER -eq $MAX_TRIES ]; then
            echo "Application did not become healthy in time."
            exit 1
          fi
          
      - name: Verify Application Health
        run: |
          # Define the health check endpoint
          HEALTH_URL="https://${{ matrix.environment }}.support.tools/healthz"
          
          # Retry parameters
          MAX_RETRIES=10
          RETRY_DELAY=30
          
          # Perform health check with retries
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL)
            
            if [ "$HTTP_STATUS" -eq 200 ]; then
              echo "✅ Application is healthy (HTTP 200)"
              exit 0
            else
              echo "❌ Health check failed with status: $HTTP_STATUS"
              
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting ${RETRY_DELAY}s before next attempt..."
                sleep $RETRY_DELAY
              fi
            fi
          done
          
          echo "Health check failed after $MAX_RETRIES attempts"
          exit 1

  # Notification job that runs on workflow failure
  Notify:
    needs: [Test, Build, Publish, Deploy]
    if: always() && (contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled'))
    runs-on: self-hosted-linux
    steps:
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: 'pipeline-alerts'
          slack-message: "Pipeline run failed! See: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
